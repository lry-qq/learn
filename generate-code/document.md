# java设计模式总结
1、单例(也可以称为单态|原子)模式 - 解决在程序运行过程中，一个类最多只能创建一个对象的问题(某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例)

单例实现步骤：
1）私有构造函数 目的是避免其他类可以创建类的对象；
2）在本类中创建唯一实例对象（因为构造函数私有化，所以单例类的唯一实例对象只能在单例类中创建），使用一个私有静态的成员变量保存
3）对外提供一个公开的静态函数供其它获取这个唯一实例对象

特点：在类加载时会创建对象
优点：类只会加载一次，所以这种写法可以保证对象的唯一性
缺点：因为类加载的时候就会创建对象，所以有时候还不需要使用对象就会创建，造成内存浪费  - 在第一次调用时再创建？如何保证对线程情况对象的唯一性？

2、原型模式(对象创建模式) - 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例
原型模式的核心是一个clone方法，通过该方法进行对象的拷贝
优点：
原型模式在内存中二进制流的拷贝，要比直接new性能好很多，如果在一个循环体内创建大量对象，原型模型就能体现出它的优点
由于是二进制的拷贝，所有构造函数不会被执行，因此使用时需要注意

使用场景：一个对象要给其他对象访问，并且其它对象可能会修改这个对象

浅克隆与深克隆：
浅克隆：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制
深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将被复制

3、工厂模式
简单工厂：不能算是真正意义上的设计模式，但可以将客户程序从具体类解耦。
工厂方法：使用继承，把对象的创建委托给子类，由子类来实现创建方法，可以看作是抽象工厂模式中只有单一产品的情况。
抽象工厂：使对象的创建被实现在工厂接口所暴露出来的方法中。
工厂模式可以帮助我们针对抽象/接口编程，而不是针对具体类编程，在不同的场景下按具体情况来使用。
4、建造者模式

5、策略模式
定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
if-else可以通过注解方式进行取代
